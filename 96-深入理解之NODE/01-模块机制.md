## 模块机制

### 模块分类

Node.js 中模块主要有两类：

* 核心模块，Node.js 本身提供的模块
* 文件模块，开发者编写的模块

### 加载步骤

Node.js 中模块加载的步骤：

* 内存直取

  对于核心模块，在 Node.js **源代码编译**时，会被同时编译成二进制文件。当应用启动时，其中部分核心模块会被直接加载进内存，所以，引入这部分核心模块时，可直接读取内存。所以它们的执行速度是最快的。

  对于文件模块，以及应用启动时未加载进内存的核心模块，为了提高性能，Node.js 会缓存模块编译和执行后的对象。所以，如果文件模块或核心模块存在缓存，则直接使用缓存，缓存也是内存。

* 文件定位

  模块标识符不同，路径分析也会有不同：

  * 核心模块，如 http、fs、path 等

    Node.js 源代码编译时，已经被编译成了二进制文件，所以加载会很快

  * 相对路径，以 "."、".." 或 "/"(相对于根目录) 开始的文件模块

    require() 方法会将路径转为真实路径，然后直接读取。在编译执行后，也会以真实路径为索引，将结果存放到缓存中，以使二次加载时更快。

    如果文件模块没有后缀，则按照 .js -> .json -> .node 顺序进行顺次匹配

  * 自定义模块，比如第三方包

    既非核心模块，又可转换为完整路径的相对路径，所以其路径分析是最耗时：

    * 首先，从当前文件目录开始递归上溯查询所有的 node_modules 目录，直至根目录
    * 其次，在任何一个 node_modules 目录下
      1. 查找并通过 JSON.parse() 解析 package.json 文件，获取其中的 main 属性，如果 main 属性文件没有后缀，则按照 .js -> .json -> .node 顺序进行顺次匹配
      2. 如果步骤 1. 不成功，比如，没有 package.json 文件 或者 main 属性，或者 main 属性错误等，则在当前目录下按照 index.js -> index.json -> index.node 顺序进行顺次匹配

* 编译执行

  不同的文件类型，其载入方法也不同：

  * .js文件

    通过 fs 模块同步读取文件后编译执行

    需要注意的是，在编译过程中，Node.js 会对获取的 JS 文件内容进行头尾包装：

    ```
    (function (exports, require, module, __filename, __dirname) {
        /* 文件模块内容 */
    });
    ```

    这样每个模块文件之间都进行了作用域隔离。

    包装之后的代码通过 vm 原生模块的 runInThisContext() 方法执行（类似eval，只是具有明确上下文，不污染全局），返回一个具体的 function 对象。

    最后，将当前模块对象的 exports 属性、require() 方法、module (模块对象自身)， 以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个 function() 执行。

    在执行之后，模块的 exports 属性被返回给了调用方。exports 属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。 

  * .json文件

    通过 fs 模块同步读取文件后，用 JSON.parse() 解析返回结果

    需要注意的是，Node.js 具有直接加载解析 JSON 文件的能力，所以，在编程中可以直接加载 .json文件。

  * .node文件

    这是用 C/C++ 编写的扩展文件，通过 process.dlopen() 方法加载最后编译生成的文件

  * 其余扩展名文件

    都被当做 .js 文件处理

  每一个编译成功的模块都会以文件路径为索引，缓存在 Module._cache 对象上，以提高二次引入的性能。


