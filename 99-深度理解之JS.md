## 各种尺寸

### 屏幕尺寸

通过 BOM 的 screen 对象可以获取屏幕相关的属性，包括屏幕尺寸。但是，使用屏幕尺寸的场景极少，这里仅做了解。屏幕尺寸属性及浏览器支持如下。

| 属性        | 说明                         | IE   | Firefox | Chrome/Safari | Opera |
| ----------- | ---------------------------- | ---- | ------- | ------------- | ----- |
| width       | 屏幕宽度                     | √    | √       | √             | √     |
| height      | 屏幕高度                     | √    | √       | √             | √     |
| availWidth  | **屏幕高度减去系统部件宽度** | √    | √       | √             | √     |
| availHeight | **屏幕宽度减去系统部件高度** | √    | √       | √             | √     |
| availTop    | 未被系统占用最顶部的值       |      | √       | √             |       |
| availLeft   | 未被系统占用最左部的值       |      | √       | √             |       |

Chrome 测试结果：

![img](./images/9901.png)

### 窗口尺寸

![img](./images/9902.png)

窗口尺寸的获取可以通过 window 的属性获取，属性名和浏览器支持如下：

| 属性        | 说明                         | IE9+ | Firefox | Chrome/Safari | Opera |
| ----------- | ---------------------------- | ---- | ------- | ------------- | ----- |
| innerWidth  | 浏览器用于显示页面的区域宽度 | √    | √       | √             | √     |
| innerHeight | 浏览器用于显示页面的区域高度 | √    | √       | √             | √     |
| outerWidth  | 整个浏览器软件界面占用的宽度 | √    | √       | √             | √     |
| outerHeight | 整个浏览器软件界面占用的高度 | √    | √       | √             | √     |

其中：

* 红框表示整个浏览器软件界面区域，蓝框表示浏览器用于显示页面的区域
* IE8- 浏览器的怪异模式中无法使用以上属性获取窗口尺寸
* 当浏览器软件最大化或者缩放时，以上尺寸会随之变化

例如：

```
console.log(`innerWidth × innerHeight -- ${window.innerWidth} × ${window.innerHeight}`);
console.log(`outerWidth × outerHeight -- ${window.outerWidth} × ${window.outerHeight}`);
```

Chrome 控制台输出：

```
innerWidth × innerHeight -- 398 × 626
outerWidth × outerHeight -- 1200 × 737
```

### 元素尺寸

#### 偏移尺寸

偏移尺寸，获取元素在屏幕上占据的可见空间以及相对其最近定位（position 不为 static）祖先元素的位置尺寸。

![img](./images/9904.png)

常用属性：

| 属性         | 说明                                          |
| ------------ | --------------------------------------------- |
| offsetTop    | 元素上边界相对其最近定位祖先元素上边界的距离  |
| offsetLeft   | 元素左边界相对其最近定位祖先元素左边界的距离  |
| offsetWidth  | 元素宽度，包括 padding、border 以及滚动条宽度 |
| offsetHeight | 元素高度，包括 padding、border 以及滚动条高度 |
| offsetParent | 元素距离最近的定位祖先元素                    |

需要注意的是：

* offsetTop 和 offsetLeft 值是相对其最近定位祖先元素的，如果元素所有祖先元素均非定位元素，则最终值是相对视口的定位值
* offsetWidth 和 offsetHeight 获取的是元素在屏幕上占据的可见空间的尺寸，所以，即便是内联元素也能获取宽高

测试代码：

![img](./images/9903.png)

```
# CSS
div {
    margin: 0;
    border: 0;
    padding: 0;
}

.wrap {
    width: 100px;
    height: 100px;
    margin: 100px 0 0 100px;
    padding: 50px;
    outline: 1px dashed #000;
    position: relative;
}

.child {
    width: 50px;
    height: 50px;
    padding: 25px;
    background: red;
    position: absolute;
    top: 50px;
    left: 50px;
}

# HTML
<div id="wrap" class="wrap">
    <div id="child" class="child"></div>
</div>

# JS
let $child = document.getElementById('child');

console.log($child.offsetWidth);	// 100
console.log($child.offsetHeight);	// 100
console.log($child.offsetTop);		// 50
console.log($child.offsetLeft);		// 50
```

 ##### 应用

1. 获取元素在文档页面上的偏移量

   思路：累加元素、定位祖先元素 … 直至最高定位祖先元素的 offsetTop/offsetLeft 值

   ```
   function getElementTop(dom) {
       let offsetTop = dom.offsetTop;
       let parentDom = dom.offsetParent;
   
       while (parentDom !== null) {
           offsetTop += parentDom.offsetTop;
           parentDom = parentDom.offsetParent;
       }
   
       return offsetTop;
   }
   
   function getElementLeft(dom) {
       let offsetLeft = dom.offsetLeft;
       let parentDom = dom.offsetParent;
   
       while (parentDom !== null) {
           offsetLeft += parentDom.offsetLeft;
           parentDom = parentDom.offsetParent;
       }
   
       return offsetLeft;
   }
   ```

#### 客户区尺寸

客户区尺寸，内边距（padding）外边界以内显示区域的尺寸，即不包括边框（border）和滚动条区域。

![img](./images/9905.png)

常用属性：

| 属性         | 说明                                  |
| ------------ | ------------------------------------- |
| clientTop    | border-top                            |
| clientLeft   | border-left                           |
| clientWidth  | padding-left + width + padding-right  |
| clientHeight | padding-top + height + padding-bottom |

需要注意的是：

* 由于没有 widht 和 height，所以行内元素的 clientWidth 和 clientHeight 永远为 0

* 如果存在区域滚动

  * 滚动隐藏的部分不包括在客户区尺寸之内
  * 滚动条的位置在 border 之内，所以，客户区尺寸是减去了滚动条区域后的尺寸
  
  ![img](./images/9907.png)

测试代码：

```
# CSS
.box {
    width: 100px;
    height: 100px;
    border: 25px solid #eee;
    padding: 25px;
}

# HTML
<div id="box" class="box"></div>

# JS
let $box = document.getElementById('box');

console.log($box.clientTop);	// 25
console.log($box.clientLeft);	// 25
console.log(`${$box.clientWidth} × ${$box.clientHeight}`);	// 150×150
console.log(`${$box.offsetWidth} × ${$box.offsetHeight}`);	// 200×200
```

##### 应用

1. 获取浏览器视口大小

   ```
   function getViewSize() {
       let $root = document.documentElement;
       let $body = document.body;	// 早期IE需要使用body获取
   
       return {
           viewW: Math.max($root.clientWidth, $body.clientWidth),
           viewH: Math.max($root.clientHeight, $body.clientHeight)
       }
   }
   ```

#### 滚动尺寸

滚动尺寸，获取包含滚动内容元素的尺寸。

![img](./images/9906.png)

常用属性：

| 属性         | 说明                     |
| ------------ | ------------------------ |
| scrollTop    | 内容区左侧被隐藏的尺寸   |
| scrollLeft   | 内容区顶部被隐藏的尺寸   |
| scrollWidth  | 没有滚动条时，元素总宽度 |
| scrollHeight | 没有滚动条时，元素总高度 |

需要注意的是：

* 由于没有 widht 和 height，所以行内元素的 scrollWidth 和 scrollHeight 永远为 0
* 滚动尺寸主要用于有滚动隐藏内容元素的尺寸，比如文档有滚动时获取完整尺寸宽度/高度
* 当文档/元素不存在滚动时，clientWidth/clientHeight 和 scrollWidth/scrollHeight 的关系在不同浏览器中表现各异

测试代码：

```
# HTML
<span id="span">唧唧复唧唧，木兰生小鸡</span>

# JS
let $span = document.getElementById('span');

console.log($span.offsetWidth);		// 176
console.log($span.offsetHeight);	// 22
console.log($span.clientWidth);		// 0
console.log($span.clientHeight);	// 0
console.log($span.scrollWidth);		// 0
console.log($span.scrollHeight);	// 0
```

```
# CSS
* {
    margin: 0;
    border: 0;
    padding: 0;
}

.wrap {
    height: 1500px;
}

# HTML
<body>
	<div id="wrap" class="wrap"></div>
</body>

# JS
let $doc = document.documentElement;

console.log($doc.clientHeight);		// 689
console.log($doc.scrollHeight);		// 1500
```

##### 应用

1. 获取文档的总高度

   基于上面的讨论，获取文档 clientWidth/scrollWidth、clientHeight/scrollHeight 中的较大值兼容不同场景最好的方式

   ```
   function getDocumentSize() {
       let $doc = document.documentElement;
   
       return {
           width: Math.max($doc.clientWidth, $doc.scrollWidth),
           height: Math.max($doc.clientHeight, $doc.scrollHeight)
       }
   }
   ```

2. 滚动元素到顶部

   注意，即便区域滚动的元素同样可以通过设置 scrollTop 属性的方式滚动元素

   ```
   function scrollToTop(dom) {
       if (dom.scrollTop !== 0) {
           dom.scrollTop = 0;
       }
   }
   ```

#### 其它方式

除了通过元素属性的方法外，还可以通过 JS 提供的 API 获取元素的尺寸。

##### window.getComputedStyle()

window.getComputedStyle() 方法返回包含元素所有计算样式的对象。

示例：

```
let $wrap = document.getElementById('wrap');

console.log(window.getComputedStyle($wrap).width);
```

##### Element.getBoundingClientRect()

Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。

![img](./images/9908.png)

返回值为一个对象，对象属性：

| 属性   | 说明                             |
| ------ | -------------------------------- |
| width  | 元素宽度                         |
| height | 元素高度                         |
| top    | 元素上边界相对视口原点的垂直距离 |
| left   | 元素左边界相对视口原点的水平距离 |
| right  | 元素右边界相对视口原点的水平距离 |
| bottom | 元素下边界相对视口原点的垂直距离 |



## 复合对象

值得思考的是，为什么很多方法存在于 Object 而不是 Object.prototype？

是否是因为，Object 作为很多子对象类型（例如数组）的超类，原型上的方法必需保证通用性，子类通过原型链继承时也需保证可用。

### 对象迭代

可迭代对象主要包括普通对象、数组、Set 集合和 Map 集合。

#### 对象

普通对象的迭代方法包括：

* for...in
* Object.keys()
* Reflect.ownKeys()
* Object.getOwnPropertyNames()
* Object.getOwnPropertySymbols()

##### for...in

以任意顺序迭代对象可枚举的自有属性以及继承属性，但不包括 Symbol 数据类型。

**Tips：**

* ES6 严格规定了对象自有属性被枚举的顺序，但是考虑历史原因，不要求 for…in 遵循此顺序
* 只迭代可枚举属性
* 不支持 Symbol 数据类型

```
let obj = Object.create({});
let symbolA = Symbol('a');
let symbolB = Symbol('b');

obj[symbolB] = 'symbolB';
obj[symbolA] = 'symbolA';

obj.title = 'title';
obj.school = 'school';

obj['2'] = 2;
obj['1'] = 1;
obj['0'] = 0;

Object.defineProperty(obj, 'mine', {
    value: function () {
        console.log('mine');
    },
    writable: false,
    enumerable: false,
    configurable: false
});

Object.defineProperty(obj.__proto__, 'proto', {
    value: function () {
        console.log('proto');
    },
    writable: true,
    enumerable: true,
    configurable: true
});

for (let key in obj) {
    console.log(key);
}

// 0 1 2 title school proto
```

##### Object.keys()

以任意顺序返回对象可枚举自有属性（不包括继承属性）组成的数组，但不包括 Symbol 数据类型。

**Tips：**

* 返回顺序要求同 for…in 一致，所以同样不遵循 ES6 中规定的迭代顺序
* 只返回自有可枚举属性，不包括从构造函数原型中继承的属性
* 不支持 Symbol 数据类型

```
let obj = Object.create({});
let symbolA = Symbol('a');
let symbolB = Symbol('b');

obj[symbolB] = 'symbolB';
obj[symbolA] = 'symbolA';

obj.title = 'title';
obj.school = 'school';

obj['2'] = 2;
obj['1'] = 1;
obj['0'] = 0;

Object.defineProperty(obj, 'mine', {
    value: function () {
        console.log('mine');
    },
    writable: false,
    enumerable: false,
    configurable: false
});

Object.defineProperty(obj.__proto__, 'proto', {
    value: function () {
        console.log('proto');
    },
    writable: true,
    enumerable: true,
    configurable: true
});

console.info(Object.keys(obj));

// ["0", "1", "2", "title", "school"]
```

##### Reflect.ownKeys()

以 ES6 规定顺序返回对象所有自有属性（不包括继承属性）组成的数组，包括不可枚举属性和 Symbol 数据类型。

**Tips：**

* ES6 规定先后顺序：
  1. 数字键按升序排序
  2. 字符串键按添加顺序
  3. Symbol 键按添加顺序
* 不包括从原型链中继承的属性
* 包括不可枚举属性
* 包括 Symbol 数据类型

```
let obj = Object.create({});
let symbolA = Symbol('a');
let symbolB = Symbol('b');

obj[symbolB] = 'symbolB';
obj[symbolA] = 'symbolA';

obj.title = 'title';
obj.school = 'school';

obj['2'] = 2;
obj['1'] = 1;
obj['0'] = 0;

Object.defineProperty(obj, 'mine', {
    value: function () {
        console.log('mine');
    },
    writable: false,
    enumerable: false,
    configurable: false
});

Object.defineProperty(obj.__proto__, 'proto', {
    value: function () {
        console.log('proto');
    },
    writable: true,
    enumerable: true,
    configurable: true
});

console.info(Reflect.ownKeys(obj));

// ["0", "1", "2", "title", "school", "mine", Symbol(b), Symbol(a)]
```

##### Object.getOwnPropertyNames()

以 ES6 规定顺序返回对象所有自有属性（包括不可枚举）组成的数组，不包括 Symbol 数据类型。

**Tips：**

- ES6 规定顺序：
  1. 数字键按升序排序
  2. 字符串键按添加顺序
- 包括不可枚举属性
- 不包括从原型链中继承的属性
- 不包括 Symbol 数据类型

```
let obj = Object.create({});
let symbolA = Symbol('a');
let symbolB = Symbol('b');

obj[symbolB] = 'symbolB';
obj[symbolA] = 'symbolA';

obj.title = 'title';
obj.school = 'school';

obj['2'] = 2;
obj['1'] = 1;
obj['0'] = 0;

Object.defineProperty(obj, 'mine', {
    value: function () {
        console.log('mine');
    },
    writable: false,
    enumerable: false,
    configurable: false
});

Object.defineProperty(obj.__proto__, 'proto', {
    value: function () {
        console.log('proto');
    },
    writable: true,
    enumerable: true,
    configurable: true
});

console.info(Object.getOwnPropertyNames(obj));

// ["0", "1", "2", "title", "school", "mine"]
```

##### Object.getOwnPropertySymbols()

以 ES6 规定顺序返回对象所有 Symbol 键组成的数组

**Tips：**

- ES6 规定顺序：
  1. Symbol 键按加入顺序
- 不包括从原型链中继承的属性
- 只包括 Symbol 数据类型
- 包括不可枚举属性

```
let obj = Object.create({});
let symbolA = Symbol('a');
let symbolB = Symbol('b');

obj[symbolB] = 'symbolB';
obj[symbolA] = 'symbolA';

obj.title = 'title';
obj.school = 'school';

obj['2'] = 2;
obj['1'] = 1;
obj['0'] = 0;

Object.defineProperty(obj, 'mine', {
    value: function () {
        console.log('mine');
    },
    writable: false,
    enumerable: false,
    configurable: false
});

Object.defineProperty(obj.__proto__, 'proto', {
    value: function () {
        console.log('proto');
    },
    writable: true,
    enumerable: true,
    configurable: true
});

console.info(Object.getOwnPropertySymbols(obj));

// [Symbol(b), Symbol(a)]
```

##### 总结

以上迭代方法，基于是否与 Symbol 数据类型相关可分为两种类型：

* for...in、Object.keys()
* Reflect.ownKeys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()

for...in 和 Object.keys() 是 Symbol 数据类型出现之前的 2 种相对古老的迭代方法

* 相同点：
  * 相同的迭代顺序，可以不遵循 ES6 迭代顺序，尽管测试 Chrome 是按 ES6 顺序迭代的
  * 只迭代可枚举属性
  * 不支持迭代 Symbol 数据类型
* 不同点：

  * for...in 包括可枚举继承属性

Reflect.ownKeys()、Object.getOwnPropertyNames() 和 Object.getOwnPropertySymbols() 是较新的规范，都支持 Symbol 数据类型

* 相同点：
  * 都严格遵守 ES6 迭代顺序
  * 都直接或间接与 Symbol 数据类型相关
  * 都会迭代不可枚举属性
  * 都不迭代继承属性
* 不同点：

  * Reflect.ownKeys() 是 Object.getOwnPropertyNames() 和 Object.getOwnPropertySymbols() 的并集

比较两类迭代方式：

* 前一类存在可以迭代继承属性的可能
* 第二类存在可以迭代不可枚举属性和 Symbol 类型的可能。

#### 数组

数组的迭代方法包括：

* for
* for...in
* ES5 迭代方法
  * Array.prototype.every()
  * Array.prototype.some()
  * Array.prototype.filter()
  * Array.prototype.sort()
  * Array.prototype.foreach()
  * Array.prototype.map()
  * Array.prototype.reduce()
  * Array.prototype.reduceRight()
* ES6 迭代方法
  * Array.prototype.keys()
  * Array.prototype.values()
  * Array.prototype.entries()
  * for...of

##### for

```
let arr = [0, 1, 2, 3];

for (let i = arr.length; i--;) {
    console.log(arr[i]);
}

// 3 2 1 0
```

while/do...while 也有类似的效果。

##### for...in

尽量不要使用 for...in 来迭代数组，因为 ES 规范并不要求 for…in 严格按照 ES6 规定顺序进行迭代，所以在不同的浏览器环境下，for...in 迭代数组时的返回顺序可能并不一致，尽管 Safari 和 Chrome 中是按 ES6  规定顺序。

```
let arr = [0, 1, 2, 3];

for (let i in arr) {
    console.log(arr[i]);
}

// 0 1 2 3
```

##### ES5迭代方法

严格的讲，Array.prototype.every/some/filter/sort/reduce/reduceRight() 并不算是迭代数组的方法，只是各自在实现自身功能时需要迭代数组罢了。

例如，Array.prototype.reduce() 对数组进行顺序累加处理，返回最终处理结果。

```
let arr = [0, 1, 2, 3];
let res = arr.reduce((pre, next) => Math.min(pre, next), -1);

console.info(res);

// -1
```

例如，Array.prototype.reduceRight() 对数组进行倒序累加处理，返回最终处理结果。

```
let arr = [0, 1, 2, 3];
let res = arr.reduceRight((pre, next) => '' + pre + next, -1);

console.info(res);

// '-13210'
```

###### Array.prototype.foreach()

对数组进行一次迭代，无返回值

```
let arr = [0, 1, 2, 3];

arr.forEach((item) => {
    console.info(item);
});

// 0 1 2 3
```

###### Array.prototype.map()

对数组进行一次迭代，返回每个元素经过处理后组成的新数组，不改变原数组。

```
let arr = [0, 1, 2, 3];
let res = arr.map(item => item * 2);

console.info(arr);
console.info(res);

// [0, 1, 2, 3]
// [0, 2, 4, 6]
```

##### ES6迭代方法

Array.prototype.keys/values/entries() 均返回一个迭代器，需要手动执行迭代器才可以完成迭代过程。当然，可以使用 for...of 完成自动迭代。

###### Array.prototype.keys()

```
let arr = ['a', 'b', 'c', 'd'];
let iterator = arr.keys();

console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().value);

// 0 1 2 3 undefined
```

###### Array.prototype.values()

```
let arr = ['a', 'b', 'c', 'd'];
let iterator = arr.values();

console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().value);

// 'a' 'b' 'c' 'd' undefined
```

###### Array.prototype.entries()

```
let arr = ['a', 'b', 'c', 'd'];
let iterator = arr.entries();

console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().value);

// [0, "a"] [1, "b"] [2, "c"] [3, "d"] undefined
```

###### for...of

for...of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环

```
let arr = ['a', 'b', 'c', 'd'];

for (let item of arr) {
    console.log(item);
}

// 'a' 'b' 'c' 'd'
```

### 对象复制

对象复制分为浅复制和深复制。两者区别在于是否允许复制对象的引用，浅复制允许复制对象的引用，所以完成顶层复制即可；深复制不允许复制对象的引用，所以必须层层遍历，直至最终所有都不是引用类型的叶子节点为止。

对象的浅复制和深复制通常用于复制 JSON 数据，所以只需要考虑结构化数据，故引用类型只需要考虑数组和普通对象。

#### 浅复制

```
function isArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
}

function isObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
}

function shallowClone(target, ...args) {
    let targetIsArray = isArray(target);
    let targetIsObject = isObject(target);

    args.forEach(source => {
        if (targetIsArray && isArray(source)) {
            return source.forEach((item, index) => {
                target[index] = item;
            });
        }

        if (targetIsObject && isObject(source)) {
            return Object.keys(source).forEach(key => {
                target[key] = source[key];
            });
        }

        throw new Error('The type of target and source is different.');
    });

    return target;
}
```

在迭代对象的时候选择 Object.keys() 而不是 for...in，是因为 for...in 需要和 hasOwnProperty 一起使用，因为它会遍历继承的可枚举属性；相比较而言， Object.keys() 更简洁。

#### 深复制

深复制的方案通常有借用 JSON 方法、递归和普通循环。

##### JSON方法

```
function isArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
}

function isObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
}

function deepClone(source) {
    if (!isArray(source) && !isObject(source)) {
        throw new Error('The type of source is wrong.');
    }

    return JSON.parse(JSON.stringify(source));
}
```

借用 JSON 方法存在的问题是：

* 实用性较差，只能整体复制一个完整的对象或数组到空对象或者空数组中；对于合并不止一个对象或数组到已有对象或数组中时，则几乎无法使用
* JSON方法内部实现依旧使用了递归，所以对象较大层级较深时，存在性能和内存溢出的风险
* 相同引用丢失和循环引用的问题，不过，两个问题的解决方法是一致的
  * 对象多个属性引用同一个对象时，相同的引用关系会丢失
  * 对象内部存在循环引用时，内存溢出，导致直接报错

##### 递归

```
function isArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
}

function isObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
}

function iterator(tar, sor, idx) {
    let sorIsArray = isArray(sor);
    let sorIsObject = isObject(sor);

    if (typeof tar[idx] === 'undefined') {
        tar[idx] = sorIsArray ? [] : sorIsObject ? {} : void 0;
    }

    let tarIsArray = isArray(tar[idx]);
    let tarIsObject = isObject(tar[idx]);

    if (tarIsArray && sorIsArray || tarIsObject && sorIsObject) {
        return deepClone(tar[idx], sor);
    }

    if (tarIsArray || sorIsArray || tarIsObject || sorIsObject) {
        throw new Error('The type of target and source is different.');
    }

    tar[idx] = sor;
}

function deepClone(target, ...args) {
    args.forEach(source => {
        if (isArray(target) && isArray(source)) {
            return source.forEach((item, index) => {
                iterator(target, item, index);
            });
        }

        if (isObject(target) && isObject(source)) {
            return Object.keys(source).forEach(key => {
                iterator(target, source[key], key);
            });
        }

        throw new Error('The type of target is wrong.');
    });

    return target;
}
```

递归方式存在的问题：

* 对象较大层级较深时，存在性能和内存溢出的风险
* 相同引用丢失和循环引用的问题

当然，可以通过改进递归调用解决相同引用丢失和循环引用的问题（改进方案见普通循环）；至于性能和内存溢出问题可以考虑 ES6 的尾调用优化（注意，需要在严格模式下实施尾调用优化）。

##### 普通循环

普通循环的原理是将递归调用转变成普通循环，从而降低时间和空间复杂度，因为，JS中一个函数往往使用一个栈帧，递归调用会创建深层嵌套的多个函数，栈帧也会随之增加；而普通 for 循环只在一个函数中，永远只在一个栈帧中运行。因此，再大对象或数组的迭代都不存在内存溢出的问题。

```
function isArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
}

function isObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
}

function deepClone(target, ...args) {
    let map = new Map();            // 存储target->source映射
    let queue = [];
    let child = null;
    let setQueue = (tar, sor) => {
        if (map.has(sor)) {         // 破解循环引用
            tar = map.get(sor);
            return;
        }

        map.set(sor, tar);

        isArray(tar) ? sor.forEach((item, index) => {
            queue.push({
                key: index,
                source: sor,
                target: tar
            });
        }) : Object.keys(sor).forEach(key => {
            queue.push({
                key: key,
                source: sor,
                target: tar
            });
        });
    };

    args.forEach(source => {
        setQueue(target, source);

        while (child = queue.pop()) {
            let key = child.key;
            let tar = child.target;
            let sor = child.source;

            let sorIsArray = isArray(sor[key]);
            let sorIsObject = isObject(sor[key]);

            if (typeof tar[key] === 'undefined') {
                tar[key] = sorIsArray ? [] : sorIsObject ? {} : void 0;
            }

            let tarIsArray = isArray(tar[key]);
            let tarIsObject = isObject(tar[key]);

            if (tarIsArray && sorIsArray || tarIsObject && sorIsObject) {
                setQueue(tar[key], sor[key]);
                continue;
            }

            if (tarIsArray || sorIsArray || tarIsObject || sorIsObject) {
                throw new Error('The type of target and source is different.');
            }

            tar[key] = sor[key];
        }
    });

    return target;
}
```

普通循环是目前最完美的深复制方案。

#### 参考

* https://segmentfault.com/a/1190000016672263

### 对象配置

#### 对象行为

ES5 增加了基本对象本身的配置和判断方法，以改变对象的行为，包括：

* Object.freeze()
* Object.isFrozen()
* Object.seal()
* Object.isSealed()
* Object.preventExtensions()
* Object.isExtensible()

##### Object.freeze()

冻结对象的所有行为，并返回该冻结对象。被冻结的行为包括：

* 不能添加新的属性或删除已有属性
* 不能修改对象属性的 enumerable、configurable 和 writable 值
* 不能修改对象属性的值
* 不能修改对象原型

需要注意的是：

* 方法返回的是被冻结的对象本身
* 通过 Object.isFrozen() 方法判断对象是否被完全冻结

```
const object1 = {
    property1: 42
};

const object2 = Object.freeze(object1);

console.log(object1 === object2);   // true

// 严格模式报错，非严格模式忽略
object1.property1 = 33;
object2.property1 = 33;

console.log(object1.property1);     // 42
console.log(object2.property1);     // 42
```

##### Object.seal()

> seal /sil/ n.密封, 海豹 v.密封

冻结对象的部分行为，并返回该密封对象。被冻结的行为包括：

- 不能添加新的属性或删除已有属性
- 不能修改对象属性的 enumerable、configurable 和 writable 值

需要注意的是：

- 方法返回的是被密封的对象本身
- 通过 Object.isSealed() 方法判断对象是否被密封
- 对象属性依旧是可写的

```
const object1 = {
    property1: 42
};

const object2 = Object.seal(object1);
console.info(object1 === object2);      // true

object1.property1 = 33;
console.log(object1.property1);         // 33
console.log(object2.property1);         // 33

// 严格模式报错，非严格模式忽略
delete object1.property1;
delete object2.property1;
console.log(object1.property1);         // 33
console.log(object2.property1);         // 33
```

##### Object.preventExtensions()

阻止对象扩展，并返回被阻止的对象本身。被冻结的行为：

* 不能添加新的属性

需要注意的是：

* 方法返回的是被阻止的对象本身
* 通过 Object.isExtensible() 方法判断对象是否可扩展
* 对象属性不可扩展，但可以删除

```
const object1 = {
    property1: 42
};

const object2 = Object.preventExtensions(object1);
console.info(object1 === object2);      // true

object1.property1 = 33;
console.log(object1.property1);         // 33
console.log(object2.property1);         // 33

delete object1.property1;
console.log(object1.property1);         // undefined
console.log(object2.property1);         // undefined

// 严格模式报错，非严格模式忽略
object1.property2 = 44;
console.log(object1.property2);         // undefined
console.log(object2.property2);         // undefined
```

#### 属性行为

ES5 增加了基本对象属性的配置和判断方法，以改变对象属性的行为，包括：

- Object.defineProperty()
- Object.defineProperties()

##### Object.defineProperty()

Object.defineProperty() 和 Object.defineProperties() 方法用于定义对象属性及其行为。

定义普通数据属性：

```
Object.defineProperty(obj, "key", {
    enumerable: false,
    configurable: false,
    writable: false,
    value: "static"
});
```

定义访问器数据属性：

```
Object.defineProperty(obj, "key", {
    get: () => { ... },
    set: (newValue) => { ... },
    enumerable: true,
    configurable: true
});
```

其中，有三个配置对象行为的特性：

* writable，是否允许修改属性值
* enumerable，是否可通过 for…in 循环枚举属性
* configurable，是否允许以下行为：
  * delete 删除该属性
  * 数据属性与访问器属性相互转换
  * 修改属性特性，即 configurable、enumerable 和 writable

### 高阶函数

#### Currying

函数柯里化和反柯里化是高阶函数的应用之一，是两个相悖的概念：

* 柯里化，currying，缩小函数适用范围，创建一个针对性更强的函数
* 反柯里化，uncurrying，扩大函数的适用范围，使函数可以应用于原本不可以应用的场景

##### 柯里化

柯里化又称部分求值，一个柯里化的函数会采用闭包的形式缓存参数，并返回另外一个函数。待到真正需要求值时再将之前缓存的参数和新传人的参数合并后统一计算。

基本实现：

```
Function.prototype.currying = function (...queue) {
    let _this = this;

    return function (...args) {
        return args.length > 0
            ? (queue = queue.concat(args))
            : _this.apply(_this, queue);
    }
}
```

使用示例：

```
function add(a, b) {
    return a + b;
}

let curry_add = add.currying(1);

curry_add(2);
curry_add();		// 3
```

Function.prototype.bind 是一个 ES 标准规定的一个柯里化函数：

```
Function.prototype.bind = function (context, ...args) {
    var _this = this;

    return function (...arguments) {
        return _this.apply(context, args.concat(arguments));
    }
}
```

###### 应用

柯里化有3个常见作用：

* 参数复用
* 提前返回
* 延迟计算

##### 反柯里化

反柯里化，扩大函数的适用范围，使函数可以应用于原本不可以应用的场景。

基本实现：

```
Function.prototype.uncurrying = function () {
    var _this = this;

    return function (context, ...arguments) {
        return _this.apply(context, arguments);
    }
}
```

使用示例：

```
var push = Array.prototype.push.uncurrying();

(function () {
    push(arguments, 4);
    console.info(arguments);
}(1, 2, 3));		// Arguments类数组 [1, 2, 3, 4]
```

## JS模块化

模块化是指解决一个复杂问题或软件系统时，自顶而下逐层把系统划分成若干高内聚，低耦合模块的过程。在模块化的设计中，模块化系统通常应该具有两方面的能力：

* 定义模块及模块依赖的能力
* 正确调用模块的能力

目前，主流的模块化方案有：

* CommonJS
* AMD（Asynchronous Module Definition）
* CMD（Common Module Definition）
* UMD
* ES Module

### CommonJS

CommonJS 是起源较早的服务端模块化解决方案，主要应用于 Node.js；随后，在应用到客户端的过程中，逐渐分化出 AMD、CMD 等模块化方案。

CommonJS 的特征是：

* 模块定义
  * 一个文件就是一个模块，Node.js 会在加载模块时将单个文件隐形的封装成模块
  * 使用 module.exports 或 exports 导出模块对象
* 模块调用
  * 同步调用，因为模块就在本地，核心 C/C++ 模块在 Node.js 编译时即编译为二级制文件，启动应用时就会加载进内存；而非 C/C++ 模块也会在初次加载时缓存编译执行的结果对象，所以速度都会很快
  * 使用 require 同步加载依赖

```
// test.js 定义模块
function test() {
    console.log('test');
}

module.exports = test;

// main.js 使用模块
let test = require('./test');
...
```

### AMD

在客户端加载远程模块时，同步加载模块会导致阻塞，所以需要采用异步加载方案。AMD 和 CMD 都是异步加载方案的具体实践方案，只是内部思想有差别。

AMD的特征是：

* 模块定义
  * 使用 define 定义模块
* 模块调用
  * 异步加载
  * 提倡依赖模块提前加载并执行，同时，也支持模块按需动态加载

AMD方案的主要代表是 require.js，其使用方法是：

定义模块：

```
define(id?, dependencies?, factory);
```

* id，模块id，字符串类型，用于模块标识，可选
* dependencies ，模块依赖，数组类型
* factory，回调函数

使用模块：

```
require([module], callback);
```

* [module]：数组，提前加载的依赖模块
* callback：模块加载之后的回调函数

### CMD

与 AMD 主要的不同是提倡模块就近加载，即延迟加载和执行。

规范文档：https://github.com/seajs/seajs/issues/242

### UMD

UMD（Universal Module Definition）是同时支持 AMD 和 CommonJS 规范的模块化机制，主要是因为两者分别采用异步和同步加载的核心思想导致使用上的不一致，而很多 JS 包需要同时运行在 Node 和 浏览器环境下。

UMD 的思路是：

* 先判断是否支持 Node.js 的模块（exports）是否存在，存在则使用 Node.js 模块模式
* 再判断是否支持 AMD（define是否存在），存在则使用 AMD 方式加载模块

```
(function (window, factory) {
    if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        define(factory);
    } else {
        window.eventUtil = factory();
    }
})(this, function () {
    //module ...
});
```

### ES Module

CommonJS、AMD、CMD 和 UMD 均是出自开发者社区非官方的 JS 模块化解决方案，而 ES Module 是 ES6 正式制定的官方模块化解决方案。

它们的联系：

* 由于 ES Module 还存在浏览器支持问题，构建时 import/export 依旧需要被转换成 require/exports 才能正常使用

它们的区别：

* 模块的定义

  ES Module 中，任何包含顶级 import 或者 export 的文件默认会被当成一个模块，有自己的独立作用域，没有顶级 import 或者 export 的模块在全局作用域内运行，这由 JS 引擎实现

  CommonJS、AMD、CMD 和 UMD 中，方案本身使用闭包创建独立作用域（如 AMD 和 CMD 的 define），只不过 Node 是自己隐形封装的

* 模块的调用

  ES Module 为**静态加载，编译时调用**；其它模块机制为**动态加载，运行时调用**

  * require 可以出现在文件的任何地方，import 需要放在文件头部
  * ES Module 支持静态分析，打包工具如 Rollup 或 Webpack 2.0+，正是利用这一点进行 tree-shaking 以删除用不到的代码
  * require 为赋值过程，简单的进行普通的值传递或者引用传递；import 是强绑定的，原文件值改变，甚至基础数据类型，被引用文件也会受到影响

  CommonJS 环境：

  ```
  // counter.js
  exports.count = 0;
  
  setTimeout(function () {
      ++exports.count;
  }, 500);
  
  
  // commonjs.js
  const {count} = require('./counter');
  
  setTimeout(function () {
      console.log(count);			// 0
  }, 1000);
  ```

  ES6 Module 环境：

  ```
  // counter.js
  export let count = 0;
  
  setTimeout(function () {
      ++count;
  }, 500);
  
  // es6.js
  import {count} from './counter';
  
  setTimeout(function () {
      console.log(count);			// 1
  }, 1000);
  ```

### 参考

* https://segmentfault.com/a/1190000004873947

## 同源策略

同源策略是 Web 应用安全的重要基石，主要目的是**限制 JS 脚本跨源访问数据**，而 HTML 中通过 iframe、img、script、link 等标签嵌入的跨域资源则不受该策略限制。同时，同源策略是浏览器实现的安全策略，服务器端的跨域请求没有同源策略限制。

同源策略出现在 1995 年的 Netscape Navigator 2 中，最初被设计用来限制对 DOM 的访问，但是随着 Web 技术的不断发展和丰富，同源策略的适用范围不断扩大。

### 定义

当 URL 的协议 protocol、域名 host 和端口 port 同时相同时，两个页面视为同源，否则为非同源。

例如，对于http://www.a.com/dir/page.html：

| URL                                                | 同源 | 原因       |
| -------------------------------------------------- | ---- | ---------- |
| http://www.a.com/dir/page2.html                    | √    | ——         |
| http://www.a.com/dir2/other.html                   | √    | ——         |
| http://username:password@www.a.com/dir2/other.html | √    | ——         |
| http://www.a.com:81/dir/other.html                 | ×    | 端口不同   |
| https://www.a.com/dir/other.html                   | ×    | 协议不同   |
| http://en.a.com/dir/other.html                     | ×    | 域名不同   |
| http://a.com/dir/other.html                        | ×    | 域名不同   |
| http://v2.www.a.com/dir/other.html                 | ×    | 域名不同   |
| http://www.a.com:80/dir/other.html                 | ——   | 依赖浏览器 |

需要注意的是：

* 同源策略并非统一规范，而是浏览器厂商出于安全目的采取的行业规范，所以在细节实现上存在差别。例如，IE 浏览器中，协议和域名相同即视为同源，所以，上面表格中的最后一个 URL 在 IE 中被视为同源，其它浏览器视为不同源。

### 实施

同源策略的安全限制主要体现在：

* Iconfont 字体跨域
* Cookie、LocalStorage 和 IndexDB 读取
* DOM 获取
* AJAX 请求

####Iconfont 

普通静态资源跨域是同源策略允许的，例如：

* js：`<script src="..."></script>`
* css：`<link rel="stylesheet" href="...">`
* \<img> 嵌入图片
* \<audio> 和 \<video> 嵌入音视频
* \<object>、\<embed>、\<applet> 嵌入插件

但对于 `@font-face` 引入的字体文件(eot|otf|ttf|woff|svg)，浏览器实现不一，有些浏览器允许跨域，有些不允许。此时可在 nginx 的静态资源服务器中加入以下配置：

```
location / {
	add_header Access-Control-Allow-Origin *;
}
```

#### Cookie

非同源页面的 Cookie 默认是不能通过 JS 相互读取的。

如果页面的一级域名相同，可以通过设置 document.domain 的方式绕过这个限制。

例如，二级域名 http://a.example.com/a.html 和 http://b.example.com/a.html 页面通过同时设置：

```
document.domain = 'example.com';
```

**需要注意的是**：这种方式只适用于页面具有相同一级域名时的 Cookie 和 Iframe 窗口，不适用于 LocalStorage 和 IndexDB 读取。

#### Iframe

非同源页面的 DOM 不能通过 JS 获取。

通常，需要进行跨域读取的应用场景主要是 Iframe。iframe 窗口或 window.open 方法打开的窗口非同源时，它们与父窗口无法直接通信，当运行以下代码时，JS直接报错：

```
// 父窗口通过子窗口contentWindow属性获取子窗口上下文
document.getElementById("myIFrame").contentWindow.document

// 子窗口通过window.parent获取父窗口上下文
window.parent.document.body
```

非同源页面 Iframe 通信的解决方案主要有以下几种方案。

##### 片段识别符

URL hash 值是 URl 中 # 号及其之后的部分，片段识别符是 URl 中 # 号之后的部分，即 hash 值去掉 # 号。

这种方案的思路是：父子窗口可以将信息写入对方 URL 的 hash 部分（不引起页面刷新），对方通过监听事件 hashchange 获取信息。

```
// 父窗口改变子窗口片段识别符
document.getElementById('myIFrame').src = originURL + '#' + data;

// 子窗口监听hashchange
window.addEventListener('hashchange', () => {
    let message = window.location.hash;
    // ...
}, false);

// 子窗口改变父窗口片段识别符
parent.location.href= target + "#" + hash;

// 父窗口监听hashchange
window.addEventListener('hashchange', () => {
    let message = window.location.hash;
    // ...
}, false);
```

##### document.domain

如果 Iframe 和父窗口 URL 的一级域名相同，可以通过与 Cookie 相同的设置 document.domain 的方式绕过这个限制。

##### window.name

window.name 有个独特的特点就是同一个窗口中，包括页面窗口和 Iframe 窗口，先后加载过的不同页面共用同一个 window.name 属性，即便先后加载的页面非同源。因此，可以通过 window.name 在两个不同的页面中传递信息。

在Iframe中可以这样使用：

* 父窗口中通过 Iframe 打开非同源页面子窗口

  ```
  window.name = data;
  ```

* 子窗口非同源页面设置 window.name 后跳转到与父窗口页面同源的新页面

  ```
  location.href = 'http://www.parent.com/a.html';
  ```

* 父窗口读取子窗口 window.name，因为此时父子窗口页面同源

  ```
  var data = document.getElementById('myFrame').contentWindow.name;
  ```

该方案的优点是：

* window.name 容量大，可以放置较长字符串数据；

该方案的缺点是：

* 监听子窗口 window.name 属性变化，影响网页性能。

##### window.postMessage

这种方案的思路是：利用跨源通信API - [window.postMessage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage) 进行窗口间通信。

```
// 父窗口打开子窗口并发送信息
let popup = window.open('http://bbb.com', 'title');
popup.postMessage('Hello World!', 'http://bbb.com');

// 子窗口向父窗口发送信息
window.opener.postMessage('Nice to see you', 'http://aaa.com');

// 父子窗口通过监听message事件获取信息
window.addEventListener('message', function (e) {
    // ...处理获取数据
}, false);
```

#### AJAX

默认情况下，AJAX 请求只能发给同源的网址，否则就报错。

跨域进行 AJAX 请求的方案有：

* JSONP
* CORS
* WebSocket
* 服务器代理

##### JSONP

JSONP 方案的基本思想是：客户端提前在全局注册一个处理数据的 callback 函数，然后通过不受同源策略限制的 \<script> 标签以 js 脚本的形式加载服务器数据，服务器采用 url 中的 callback 名称将数据封装成 js 脚本返回给客户端执行。

```
// 客户端jsonp实现
function jsonp(url, callback) {
    var name = 'callback' + new Date().getTime();

    window[name] = function (data) {
        setTimeout(function () {
            callback(data);
            delete window[name];
        }, 0);
    };

    var script = document.createElement('script');

    script.setAttribute('src', url + '&callback=' + name);
    script.addEventListener('load', function () {
        document.body.removeChild(script);
    });

    document.body.appendChild(script);
};

// 服务端以脚本形式封装数据
callback1544452369433({
    "status": {
        "code": 0,
        "message": ""
    },
    "result": {
        ...
    }
});
```

JSONP 的优点是：

- 支持老式浏览器，可以向不支持 CORS 的网站请求数据

JSONP 的缺点是：

* 相比于 CORS，JSONP 是一种非官方的hack方式，只支持 GET 请求，CORS 支持所有类型的 HTTP 请求

##### CORS

CORS，Cross-Origin Resource Sharing，跨域资源共享，是官方制定的跨域访问规范。目前，除了 < 10的 IE 浏览器，主流浏览器皆支持 CORS。

CORS 的实现原理：通信过程由浏览器自行完成，**浏览器一旦发现 AJAX 请求跨源，会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉**。

CORS 的实现关键：通信的关键是服务器，只要服务器实现了 CORS 接口，就可以跨源通信。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。

CORS 的请求分类：简单请求（simple request）和非简单请求（not-so-simple request）。浏览器对两者的处理方式略有不同，主要是对于非简单请求，在正式进行请求前，需要增加一次 HTTP 查询请求进行“预检”。

![img](./images/9900.png)

###### 简单请求

所谓简单请求，就是满足以下两个条件的请求，否则为非简单请求。

1. 请求方法是以下三种方法之一：
   * **HEAD**
   * **GET**
   * **POST**

2. HTTP 的头信息不超出以下几种字段：
   * Accept
   * Accept-Language
   * Content-Language
   * Last-Event-ID
   * **Content-Type：只限于三个基本值**
     * **application/x-www-form-urlencoded**
     * **multipart/form-data**
     * **text/plain**

**对于简单跨域请求，浏览器发出 CORS 请求。不过，请求头信息中会增加Origin（协议 + 域名 + 端口）字段，用于告诉服务端请求来源。**

```
GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

如果 Origin 指定的域名在许可范围内，服务器返回的响应，会多出以下几个头信息字段。

```
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
```

其中：

* Access-Control-Allow-Origin：它的值要么是请求时 Origin 字段的值，要么是*（接受任意域名请求）

* Access-Control-Allow-Credentials：可选布尔值，默认 false，表示服务端是否允许客户端发送 Cookie。如果服务端需要验证用户信息，需要服务端和客户端同时进行设置，两者缺一不可。

  * 服务端，需要同意接受认证信息，即：

    ```
    Access-Control-Allow-Credentials: true
    ```

  * 客户端，默认情况下 CORS 请求不发送 Cookie 和 HTTP 认证信息。需要打开 AJAX 的 withCredentials 属性：

    ```
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = true;
    ```

  **需要注意的是：**

  * 不同浏览器实现稍有差异，当没有 withCredentials 属性时，部分浏览器还是会发送 Cookie，可以显式设置该属性值为 false 关闭这种行为

    ```
    xhr.withCredentials = false;
    ```

  * 如果要发送 Cookie，Access-Control-Allow-Origin 就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源策略，只有用服务器域名设置的 Cookie 才会上传，其他域名的Cookie 并不会上传，且（跨源）原网页代码中的 document.cookie 也无法读取服务器域名下的 Cookie

* Access-Control-Expose-Headers：指示除了以下基本首部外，客户端 XMLHttpRequest 对象可以通过 getResponseHeader() 方法获得的其它首部

  * Cache-Control
  * Content-Language
  * Content-Type
  * Expires
  * Last-Modified
  * Pragma

**如果 Origin 指定域名不在许可范围内，服务器会返回没有 Access-Control-Allow-Origin 首部的正常 HTTP 回应，浏览器据此判断出错，从而抛出可以被 XMLHttpRequest 的 onerror 回调捕获的错误。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。**

###### 非简单请求

非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application/json。

非简单请求的过程分为两个阶段：

1. 预检请求

   非简单 CORS 请求会在正式通信之前，增加一次 HTTP 查询请求，称为"预检"请求（preflight）。

   **浏览器通过 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 请求首部询问服务器，当前域名是否在许可范围内，以及 HTTP 方法和首部字段是否被允许。**

   ```
   var url = 'http://api.alice.com/cors';
   var xhr = new XMLHttpRequest();
   xhr.open('PUT', url, true);
   xhr.setRequestHeader('X-Custom-Header', 'value');
   xhr.send();
   ```

   上面 HTTP 请求的方法是 PUT，并且发送一个自定义头信息 X-Custom-Header。浏览器发现，这是一个非简单请求，就自动发出一个"预检"请求，要求服务器确认可以这样请求。下面是这个"预检"请求的HTTP头信息：

   ```
   OPTIONS /cors HTTP/1.1
   Origin: http://api.bob.com
   Access-Control-Request-Method: PUT
   Access-Control-Request-Headers: X-Custom-Header
   Host: api.alice.com
   Accept-Language: en-US
   Connection: keep-alive
   User-Agent: Mozilla/5.0...
   ```

   其中：

   * OPTIONS：请求方法，表示这个请求是用来询问的
   * Origin：请求来自哪个源
   * Access-Control-Request-Method：必须，标识浏览器 CORS 请求会用到的 HTTP 方法，这里是 PUT
   * Access-Control-Request-Headers：浏览器 CORS 请求会额外发送的头信息字段，多个时以逗分割

   **服务器收到"预检"请求以后，检查 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以确认是否允许该跨源请求，如若允许给予包含 CORS 相关首部的相应。**

   ```
   HTTP/1.1 200 OK
   Date: Mon, 01 Dec 2008 01:15:39 GMT
   Server: Apache/2.0.61 (Unix)
   Access-Control-Allow-Origin: http://api.bob.com
   Access-Control-Allow-Methods: GET, POST, PUT
   Access-Control-Allow-Headers: X-Custom-Header
   Content-Type: text/html; charset=utf-8
   Content-Encoding: gzip
   Content-Length: 0
   Keep-Alive: timeout=2, max=100
   Connection: Keep-Alive
   Content-Type: text/plain
   ```

   其中：

   * Access-Control-Allow-Origin：与简单请求一样指定请求 Origin 值或 *，表示允许当前 Origin 跨域请求

   * Access-Control-Allow-Methods：服务器支持的所有跨域请求的方法，注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求

   * Access-Control-Allow-Headers：如果浏览器请求包括该字段，则服务器响应时该字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段

   * Access-Control-Allow-Credentials：服务端可能响应首部，意义与简单请求相同

   * Access-Control-Max-Age：服务端可能响应首部，用来指定本次预检请求的有效期，单位为秒，例如：

     ```
     Access-Control-Max-Age: 1728000
     ```

   **如果服务器拒绝"预检"请求，与简单请求一样，会返回一个没有任何 CORS 相关首部的正常 HTTP 回应，浏览器据此判断服务器不同意预检请求，从而抛出可以被 XMLHttpRequest 的 onerror 回调捕获的错误。**控制台会打印出如下的报错信息：

   ```
   XMLHttpRequest cannot load http://api.alice.com.
   Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
   ```

2. 正式请求

**一旦服务器通过"预检"请求，浏览器才会发出正式的 XMLHttpRequest 请求。之后的每次 CORS 请求，都跟简单请求一样，会有 Origin 首部字段。服务器回应包含 Access-Control-Allow-Origin 首部的响应**。

下面是"预检"请求之后，浏览器的正常CORS请求：

```
PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

上面头信息的Origin字段是浏览器自动添加的。下面是服务器正常的回应：

```
Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
```


上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。

##### WebSocket

WebSocket 是一种通信协议，使用 `ws://`（非加密）和 `wss://`（加密）作为协议前缀。该方案的思路是：WebSocket 协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。

浏览器发出的WebSocket请求头信息：

```
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
```

其中，Origin表示发起该请求的页面域名。正是因为有了Origin这个字段，WebSocket才没有实行同源策略，因为服务器可以根据这个字段，决定是否允许通信。如果该域名在白名单内，服务器就会做出如下回应：

```
HTTP/1.1 101 Switching Protoco
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```

原生 WebSocket 详细教程请参见[runoob](http://www.runoob.com/html/html5-websocket.html)，下面使用 Socket.io，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。

前端实现：

```
<div>user input：<input type="text"></div>

<script src="./socket.io.js"></script>
<script>
    var socket = io('http://www.domain2.com:8080');

    // 连接成功处理
    socket.on('connect', function() {
        // 监听服务端消息
        socket.on('message', function(msg) {
            console.log('data from server: ---> ' + msg); 
        });

        // 监听服务端关闭
        socket.on('disconnect', function() { 
            console.log('Server socket has closed.'); 
        });
    });

    document.getElementsByTagName('input')[0].onblur = function() {
        socket.send(this.value);
    };
</script>
```

Node socket 后台：

```
var http = require('http');
var socket = require('socket.io');

// 启http服务
var server = http.createServer(function(req, res) {
    res.writeHead(200, {
        'Content-type': 'text/html'
    });
    
    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');

// 监听socket连接
socket.listen(server).on('connection', function(client) {
    // 接收信息
    client.on('message', function(msg) {
        client.send('hello：' + msg);
        console.log('data from client: ---> ' + msg);
    });

    // 断开处理
    client.on('disconnect', function() {
        console.log('Client socket has closed.'); 
    });
});
```

##### 服务端代理

同源策略是客户端浏览器的安全策略，并不是 HTTP 协议的一部分。服务器端调用 HTTP 接口只是使用 HTTP 协议，不会执行 JS 脚本，不受同源策略限制，也不存在跨越问题。

服务端代理的常用方式有两种：

* PHP 服务端代理
* nginx 反向代理
* Node 中间件代理

###### PHP 服务端代理

如果应用使用 PHP 实现，可以在页面服务器端 (同源) 实现 PHP 中转代理接口，即：

* 前端页面向同源 PHP 接口发起请求
* 服务器端的 PHP 接口转发请求到跨域接口

######nginx 反向代理

实现思路：通过 nginx 配置一个代理服务器（域名与浏览器页面域名相同，端口不同）做跳板机，反向代理访问跨域目标接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。

nginx 具体配置：

```
#proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;

    location / {
        proxy_pass   http://www.domain2.com:8080;  			 # 反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; # 修改cookie里域名
        index  index.html index.htm;

        # 当 webpack-dev-server 等中间件代理接口访问nginx时，
        # 无浏览器参与，没有同源限制，下面的跨域配置可不启用
        # 当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Origin http://www.domain1.com;
        add_header Access-Control-Allow-Credentials true;
    }
}
```

前端 Ajax 请求：

```
var xhr = new XMLHttpRequest();

// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;

// 访问nginx中的代理服务器
xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);
xhr.onload = function (){ ... }
xhr.send();
```

Node 后台：

```
var http = require('http');
var server = http.createServer();
var qs = require('querystring');

server.on('request', function(req, res) {
    var params = qs.parse(req.url.substring(2));

    // 向前台写cookie
    res.writeHead(200, {
        'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'
    });

    res.write(JSON.stringify(params));
    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');
```

###### Node 中间件代理

node 中间件实现跨域的原理与 nginx 反向代理相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中域名，实现当前域的 cookie 写入，方便接口登录认证。

前端 Ajax 请求：

```
var xhr = new XMLHttpRequest();

// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;

// 访问http-proxy-middleware代理服务器
xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);
xhr.onload = function (){ ... }
xhr.send();
```

中间件服务器：

```
var express = require('express');
var proxy = require('http-proxy-middleware');
var app = express();

app.use('/', proxy({
    // 代理跨域目标接口
    target: 'http://www.domain2.com:8080',
    changeOrigin: true,

    // 修改响应头信息，实现跨域并允许带cookie
    onProxyRes: function(proxyRes, req, res) {
        res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');
        res.header('Access-Control-Allow-Credentials', 'true');
    },

    // 修改响应信息中的cookie域名
    cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
}));

app.listen(3000);
console.log('Proxy server is listen at port 3000...');
```

Node 后台：

```
var http = require('http');
var server = http.createServer();
var qs = require('querystring');

server.on('request', function(req, res) {
    var postData = '';

    // 数据块接收中
    req.addListener('data', function(chunk) {
        postData += chunk;
    });

    // 数据接收完毕
    req.addListener('end', function() {
        postData = qs.parse(postData);

        // 跨域后台设置
        res.writeHead(200, {
        	// 后端允许发送Cookie
            'Access-Control-Allow-Credentials': 'true',
            
            // 允许访问的域（协议+域名+端口）
            'Access-Control-Allow-Origin': 'http://www.domain1.com',
            
            // cookie Domain是domain2而非domain1，因为后端不能跨域写cookie(nginx反向代理可以实现)
            // 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie
            // 从而实现所有的接口都能跨域访问
            'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'
        });

        res.write(JSON.stringify(postData));
        res.end();
    });
});

server.listen('8080');
console.log('Server is running at port 8080...');
```

#### 其它

如果跨域只是限制了如 log 之类的简单单项通信，根据 \<img>、\<script>、\<link>、\<iframe> 元素的 src/href 属性不存在跨域的特征，可以通过将其 src/href 属性设置为目标 URL 的方式进行上报。

### 参考

* https://en.wikipedia.org/wiki/Same-origin_policy
* http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html
* http://www.ruanyifeng.com/blog/2016/04/cors.html
* https://segmentfault.com/a/1190000011145364
* https://segmentfault.com/a/1190000012469713
* https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy

## 文件读取

JS 对文件的操作。

### 相关 API

#### URL

URL，用以创建和解析 url 路径，是 Object 对象的直接子对象。

除 IE 全系外，包括 Edge 在内的主流浏览器的较新版本皆支持 URL 对象。

##### 创建

URL 对象创建方法：

```
const url = new URL(urlString, [baseURLstring]);
const url = new URL(urlString, baseURLobject);
```

* urlString，一个绝对或相对的 URL
* baseURLstring，可选，urlString 为相对 URL 时使用的基本 URL 参考
* baseURLobject，urlString 为相对 URL 时使用的参考 URL 对象

需要注意的是：

* 早期 WebKit 需要使用 Window.webkitURL 兼容

##### 属性

URL 对象支持的属性：

* href，完整的 URL
* protocol，协议名，末尾带 ':'
* host，域名 + 端口号
* hostname，域名
* port，端口号
* pathname，以 '/' 开始的文件路径
* search，以 '?' 开始的请求参数
* hash，以 '#' 开始的 hash
* username，域名前面指定的用户名
* password，域名前面指定的密码
* origin，协议名 + 域名 + 端口号
* searchParams，当前 URL GET 请求参数的 URLSearchParams 对象

##### 方法

URL 对象支持的方法：

* toString()，返回完整的 URL 的 DOMString

URL 对象支持的静态方法：

> 注：这里的静态方法是 URL 构造函数本身具有的方法。

> Blob URL，blob 链接，是一种伪协议，允许 Blob 和 File 对象用作图像、下载二进制数据链接等的 URL 源，其基本格式为：
>
> ```
> blob:{唯一标识对象的掩码}
> ```
>
> 例如：
>
> ```
> blob:https://h5.flying.com/25e182fd-513f-4928-8186-22818c08ed8a
> ```

* URL.createObjectURL()，指向 Blob 或 File 对象的 blob 链接

  ```
  let objectURL = URL.createObjectURL(blob);
  ```

  * blob，用来创建 URL 的 Blob 或 File 对象

* URL.revokeObjectURL()，销毁 URL.createObjectURL() 创建的 URL 实例，保证性能

##### 参考

* https://developer.mozilla.org/zh-CN/docs/Web/API/URL
* https://cloud.tencent.com/developer/ask/98562

#### Blob

> blob /blɒb/

Blob，Binary Large Object，二进制大型对象，用于保存文件的类文件对象，是 Object 对象的直接子对象。

##### 创建

Blob 对象创建语法：

```
var blob = new Blob( array, options );
```

* array，一个由 ArrayBuffer、ArrayBufferView、Blob、DOMString 等对象构成的 Array ，或者其他类似对象的混合体
* options，一个可选对象，可以属性：
  * type，默认值 ""，表示放入 blob 中的数组内容的MIME类型
  * endings，默认值 "transparent"，用于指定包含行结束符 \n 的字符串如何被写入，可用值：
    * "native"，行结束符会被更改为适合宿主操作系统文件系统的换行符
    * "transparent"，会保持 blob 中结束符不变

使用示例：

```
// 一个包含DOMString的数组
var aFileParts = ['<a id="a"><b id="b">hey!</b></a>'];

// 创建 blob
var oMyBlob = new Blob(aFileParts, {type : 'text/html'});
```

##### 属性

Blob 对象支持的属性：

* size，对象中包含数据的大小，单位字节
* type，对象中包含数据的 MIME 类型。如果类型未知，则该值为空字符串

##### 方法

Blob 对象支持的方法：

* slice，用于创建一个包含源 Blob 指定字节范围内数据的新 Blob 对象，语法：

  ```
  var blob = instanceOfBlob.slice([start [, end [, contentType]]]};
  ```

  * start，默认为 0，拷贝进新 Blob 对象的字节起始位置，该起始值包含在内，负数从末尾倒数
  * end，默认为源对象 size，拷贝进新 Blob 对象的字节结束位置，该结束值不包含在内，负数从末尾倒数
  * contentType，新 Blob 对象的 MIME 类型，默认值为空字符串

  使用该方法需要注意的是：

  * 无任何参数时，相当于将源 Blob 对象完整复制一份
  * 如果 start ~ end 指示的范围大于 0 ~ 源 Blob 对象 ，则也相当于将源 Blob 对象完整复制一份
  * 在早期浏览器中需要添加浏览器前缀：Firefox - mozSlice，WebKit - webkitSlice

#### File

File，文件对象，是 Blob 对象的直接子对象，即 File 对象的原型链为：File -> Blob -> Object

File 对象作为 Blob 对象的子类，可以用在任意 Blob 类型的 context 中。比如，以下场景可以同时处理 Blob 和 File：

* FileReader
* URL.createObjectURL()
* createImageBitmap()
* XMLHttpRequest.send()

##### 创建

File 对象创建语法：

```
var myFile = new File(bits, name[, options]);
```

* bits，由 ArrayBuffer、ArrayBufferView、Blob、DOMString 对象构成的 Array，或者这些对象的组合
* name，USVString，文件名称或者文件路径
* options，选项对象，可用选项：
  * type，DOMString，将要放到文件中的内容 MIME 类型，默认值为 ""
  * lastModified，数值，文件最后修改时间的时间，单位毫秒，默认值为 Date.now()。

需要注意的是：

* File 构造函数在编程中并不常用，主要是浏览器内部实现中使用，其出现的地方：

  *  input 元素选择文件后返回的 FileList 对象中的元素

    ```
    input.onchange = function (e) {
    		let files = e.target.files;					// FileList 对象
    		let file = files[0];								// File 对象
    }
    ```

  * 原生拖放操作生成的 DataTransfer 对象

    ```
    drop.addEventListener('drop', function (e) {
    		let files = e.dataTransfer.files;		// FileList 对象
    		let file = files[0];								// File 对象
    }, false);
    ```

##### 属性

File 对象支持的属性：

* lastModified，只读，引用文件的最后修改时间
* lastModifiedDate，只读，引用文件最后修改时间的 Date 对象
* name，只读，引用文件的名字
* size，只读，文件的大小，继承自 Blob
* type，只读，引用文件的 MIME 类型，继承自 Blob

##### 方法

File 对象支持的方法：

* slice，用于创建一个包含指定字节范围内数据的新 Blob 对象，继承自 Blob，用法同 Blob

#### FileList

FileList，File 对象的类数组序列。

FileList 对象并不能直接创建，主要是浏览器内部实现中使用，其出现的地方同 File 对象相同：

* input 元素选择文件后返回的 FileList 对象中的元素
* 原生拖放操作生成的 DataTransfer 对象

##### 属性

FileList 对象支持的属性：

* length，包含的 File 对象数量

#### FileReader

> 注：JS 不允许直接读取文件，只能被动获取文件对象，所以，FileReader 不能直接从用户系统读取文件。

FileReader 对象用于异步从 Blob 或 File 对象中读取文件内容，所以，在使用 FileReader 时需要优先获取 Blob 或 File 对象的 引用。

除 IE 全系支持的都不好外，包括 Edge 在内的主流浏览器的较新版本皆支持 FileReader 对象。

##### 创建

FileReader 对象创建语法：

```
var reader = new FileReader();
```

注意，无参数。

##### 属性

FileReader 对象支持的属性：

* error，读取文件时发生的错误

* FileReader，读取状态，可用值

  | 值   | 常量名  | 描述             |
  | ---- | ------- | ---------------- |
  | 0    | EMPTY   | 还未加载任何数据 |
  | 1    | LOADING | 数据正在被加载   |
  | 2    | DONE    | 加载数据已完成   |

* result，文件内容，仅在读取完成后有效，数据格式取决于使用的读取方法

##### 事件

FileReader 对象支持的事件：

* abort，读取操作被中断时触发
* error，读取操作发生错误时触发
* load，读取操作完成时触发
* loadstart，读取操作开始时触发
* loadend，读取操作结束时触发，不论成功或者失败
* progress，读取过程中触发

需要注意的是：

* FileReader 继承自 EventTarget，所以上述事件可以通过 on 函数或 addEventListener 两种方式使用

##### 方法

FileReader 对象支持的方法：

* abort()，中止读取操作，在返回时，readyState属性为 DONE
* readAsArrayBuffer()，开始读取，完成时，result 属性保存的是文件的 ArrayBuffer 格式数据
* readAsBinaryString() ，开始读取，完成时，result 属性保存的是文件的原始二进制数据
* readAsDataURL()，开始读取，完成时，result 属性保存的是文件的 data:URL 格式的字符串
* FileReader.readAsText()，开始读取，完成时，result 属性保存的是文件的字符串格式内容

### 实践示例

#### 读取图片

示例代码1：

```
# HTML
<input type="file" id="take-picture">
<img id="show-picture">

# JS
let takePicture = document.querySelector("#take-picture");
let showPicture = document.querySelector("#show-picture");

takePicture.onchange = function (e) {
    let files = e.target.files,
        file;

    if (!files || !files.length) {
        return;
    }

    file = files[0];

		// 创建 FileReader 对象
    let fileReader = new FileReader();

    fileReader.onload = function (e) {
        showPicture.src = e.target.result;
    };

    fileReader.readAsDataURL(file);
};
```

示例代码2：

```
# HTML
<input type="file" id="take-picture">
<img id="show-picture">

# JS
let takePicture = document.querySelector("#take-picture");
let showPicture = document.querySelector("#show-picture");

takePicture.onchange = function (e) {
    let files = e.target.files,
        file;

    if (!files || !files.length) {
        return;
    }

    file = files[0];
    
    // 创建对象 URL 字符串
    let URL = window.URL || window.webkitURL;
    let imgURL = URL.createObjectURL(file);

		// 释放 URL 对象以提高性能，注意必需在加载后释放，否则还没加载就释放会报错
    showPicture.onload = function () {
        URL.revokeObjectURL(imgURL);
    }

    showPicture.src = imgURL;
};
```

## 细节学习

### parseInt

parseInt 的基本语法：

```
parseInt(string, radix);
```

参数：

* string，要解析的字符串
* radix，可选基数，2~36 之间的整数。如果为 undefined 或 0，则：
  * string 以"0x"或者"0X"开头，基数是16 (16进制)
  * string 以"0"开头，基数是8（八进制）或者10（十进制），具体由实现环境决定。ES 5 规定使用 10，但并不是所有浏览器都遵循这个规定。因此，始终建议明确给出 radix 参数的值
  * string 以其它任何值开头，则基数是10 (十进制)

返回值：

* 如果解析成功，返回解析后的整数
* 如果解析失败，返回 NaN

#### 习题1

```
['1', '2', '3'].map(parseInt)			// [1 NaN NaN]
```

#### 习题2

```
let unary = fn => val => fn(val)
let parse = unary(parseInt)

['1.1', '2', '0.3'].map(parse)		// [1, 2, 0]
```

### eval & Function

eval & Function 都可以用来通过字符串创建可执行语句。

#### eval

eval 函数将传入的字符串当做  JS 代码进行，其语法：

```
eval(string)
```

* string

  JS 表达式，语句或一系列语句的字符串；表达式可以包含变量以及已存在对象的属性

需要注意的是：

* 如果直接运行 eval，其执行作用域为当前局部作用域；但是，如果通过引用间接执行 eval，从 ES5 开始，它工作在全局作用域下，而不再是局部作用域 (出于安全考虑)

  ```
  function test() {
      var x = 2, y = 4;
      
      // 直接调用，使用本地作用域，结果是 6
      console.log(eval("x + y"));
      
      // 间接调用，使用全局作用域，throws ReferenceError 因为`x`未定义
      var geval = eval;
      console.log(geval("x + y"));
      
      // 另一间接调用的例子
      (0, eval)('x + y');
  }
  ```

* 尽可能避免使用 eval，因为：

  * 性能差，eval 通常比替代方法慢，因为它必须调用 JS 解释器
  * 安全性差，因为：
    * eval 可以直接执行字符串，字符串中可能含有恶意代码
    * eval 可以访问到执行时的局部作用域

#### Function

Function()  构造函数用于创建一个新的函数对象，其语法：

```
new Function ([arg1[, arg2[, ...argN]],] functionBody)
```

* arg1, arg2, ... argN

  函数参数名称，必须是合法命名的

* functionBody

  函数定义的 JS 语句字符串

需要注意的是：

* new Function() 创建的函数不在创建它的上下文中创建闭包，一般在全局作用域创建，所以只能访问自己的本地变量和全局变量，不能访问创建时所在的上下文作用域。这点和 eval 不同！！！

  ```
  let scope = 'global scope';
  
  function b() {
      let scope = 'local scope';
  
      eval('console.log(scope)');                 // local scope
      (new Function('console.log(scope)'))();     // global scope
  }
  
  b()
  ```

* 可以通过 CSP 禁用 new Function() 和 eval

  例如，下面通过 meta 启用 CSP，content 中 script-src 设置如果没有 'unsafe-eval' 属性，就表示禁用 new Function() 和 eval

  ```
  <meta http-equiv="content-security-policy" 
  			content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval';">
  ```


### addEventListener

#### 第三个参数是 false？

根本原因，事件流最初来自于 IE 和 Netscape，但是 IE 的事件流是冒泡流，Netscape 的事件流是捕获流。IE 9+ 开始支持捕获流，从而最终形成了今天 `捕获流 → 目标元素 → 冒泡流` 的完整事件流机制。但是，老版本 IE 不支持捕获流，因为早期兼容市场份额较大的 IE 浏览器，前端才养成了只使用捕获流的习惯。

其它原因，使用捕获流更合理，因为

* 事件始终都是要在目标元素上触发的，如果不希望在外层元素上触发，可以阻止冒泡，使用捕获流如何操作？
* 从性能方面考虑，前端通常使用事件委托，使用冒泡流可以捕捉到内层所有元素上的事件；如果使用捕获流，如何委托？难道在最内层的元素上捕获所有外层的事件吗？这不是合乎正常思维的方式 吧？！















































